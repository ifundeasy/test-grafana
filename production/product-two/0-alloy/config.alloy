
livedebugging {
	enabled = true
}

logging {
	level  = "info"
	format = "logfmt"
}

discovery.kubernetes "pod" {
	role = "pod"

	namespaces {
		names = ["product-two"]
	}
}

discovery.relabel "pod_relabel" {
	targets = discovery.kubernetes.pod.targets

	// Handle ReplicaSet (from Deployment)
	rule {
		source_labels = ["__meta_kubernetes_pod_controller_kind", "__meta_kubernetes_pod_controller_name"]
		separator     = "/"
		regex         = "ReplicaSet/(.+)"
		target_label  = "__tmp_replicaset_name"
		replacement   = "${1}"
	}

	// Extract deployment name from ReplicaSet name
	rule {
		source_labels = ["__tmp_replicaset_name"]
		regex         = "(.+)-[a-z0-9]+"
		target_label  = "__tmp_deployment_name"
		replacement   = "${1}"
	}

	// Handle direct Deployment controller
	rule {
		source_labels = ["__meta_kubernetes_pod_controller_kind", "__meta_kubernetes_pod_controller_name"]
		separator     = "/"
		regex         = "Deployment/(.+)"
		target_label  = "__tmp_deployment_name"
		replacement   = "${1}"
	}

	// Handle StatefulSet
	rule {
		source_labels = ["__meta_kubernetes_pod_controller_kind", "__meta_kubernetes_pod_controller_name"]
		separator     = "/"
		regex         = "StatefulSet/(.+)"
		target_label  = "__tmp_deployment_name"
		replacement   = "${1}"
	}

	// Handle DaemonSet
	rule {
		source_labels = ["__meta_kubernetes_pod_controller_kind", "__meta_kubernetes_pod_controller_name"]
		separator     = "/"
		regex         = "DaemonSet/(.+)"
		target_label  = "__tmp_deployment_name"
		replacement   = "${1}"
	}

	// Handle Job
	rule {
		source_labels = ["__meta_kubernetes_pod_controller_kind", "__meta_kubernetes_pod_controller_name"]
		separator     = "/"
		regex         = "Job/(.+)"
		target_label  = "__tmp_deployment_name"
		replacement   = "${1}"
	}

	// Fallback: use pod controller name directly if no specific pattern matches
	rule {
		source_labels = ["__tmp_deployment_name"]
		regex         = ""
		target_label  = "__tmp_deployment_name"
		replacement   = ""
	}

	rule {
		source_labels = ["__meta_kubernetes_pod_controller_name"]
		target_label  = "__tmp_fallback_name"
	}

	rule {
		source_labels = ["__tmp_deployment_name", "__tmp_fallback_name"]
		separator     = ""
		regex         = "^$(.+)"
		target_label  = "__tmp_deployment_name"
		replacement   = "${1}"
	}

	// Set final labels
	rule {
		source_labels = ["__tmp_deployment_name"]
		target_label  = "service_name"
	}

	rule {
		source_labels = ["__tmp_deployment_name"]
		target_label  = "deployment_name"
	}
}

// ── LOGGING ─────────────────────────────────────────────
loki.write "producttwo" {
	endpoint {
		url     = "http://loki.local/loki/api/v1/push"
		headers = {
			"X-Scope-OrgID" = "myorg-production-producttwo",
		}
	}
}

loki.source.kubernetes "producttwo" {
	targets = discovery.relabel.pod_relabel.output
	forward_to = [loki.write.producttwo.receiver]
}

// ── TRACING ─────────────────────────────────────────────
otelcol.receiver.otlp "producttwo" {
	grpc {
		endpoint = "0.0.0.0:4317"
	}

	http {
		endpoint = "0.0.0.0:4318"
	}

	output {
		traces = [otelcol.processor.attributes.producttwo.input]
	}
}

otelcol.processor.attributes "producttwo" {
	action {
		key    = "business-unit"
		value  = "product-one"
		action = "insert"
	}
	
	// Replace service.name with deployment name from Kubernetes metadata
	action {
		key    = "service.name"
		from_attribute = "k8s.deployment.name"
		action = "upsert"
	}

	output {
		traces = [otelcol.processor.batch.producttwo.input]
	}
}

otelcol.processor.batch "producttwo" {
	output {
		traces = [otelcol.exporter.otlp.producttwo.input]
	}
}

otelcol.exporter.otlp "producttwo" {
	client {
		endpoint = "tempo.local:8444"
		headers  = {
			"X-Scope-OrgID" = "myorg-production-producttwo",
		}

		tls {
			insecure = true
			insecure_skip_verify = true
		}
	}
}content: |
livedebugging {
	enabled = true
}

logging {
	level  = "info"
	format = "logfmt"
}

discovery.kubernetes "pod" {
	role = "pod"

	namespaces {
		names = ["product-one"]
	}
}

discovery.relabel "pod_relabel" {
	targets = discovery.kubernetes.pod.targets

	// Handle ReplicaSet (from Deployment)
	rule {
		source_labels = ["__meta_kubernetes_pod_controller_kind", "__meta_kubernetes_pod_controller_name"]
		separator     = "/"
		regex         = "ReplicaSet/(.+)"
		target_label  = "__tmp_replicaset_name"
		replacement   = "${1}"
	}

	// Extract deployment name from ReplicaSet name
	rule {
		source_labels = ["__tmp_replicaset_name"]
		regex         = "(.+)-[a-z0-9]+"
		target_label  = "__tmp_deployment_name"
		replacement   = "${1}"
	}

	// Handle direct Deployment controller
	rule {
		source_labels = ["__meta_kubernetes_pod_controller_kind", "__meta_kubernetes_pod_controller_name"]
		separator     = "/"
		regex         = "Deployment/(.+)"
		target_label  = "__tmp_deployment_name"
		replacement   = "${1}"
	}

	// Handle StatefulSet
	rule {
		source_labels = ["__meta_kubernetes_pod_controller_kind", "__meta_kubernetes_pod_controller_name"]
		separator     = "/"
		regex         = "StatefulSet/(.+)"
		target_label  = "__tmp_deployment_name"
		replacement   = "${1}"
	}

	// Handle DaemonSet
	rule {
		source_labels = ["__meta_kubernetes_pod_controller_kind", "__meta_kubernetes_pod_controller_name"]
		separator     = "/"
		regex         = "DaemonSet/(.+)"
		target_label  = "__tmp_deployment_name"
		replacement   = "${1}"
	}

	// Handle Job
	rule {
		source_labels = ["__meta_kubernetes_pod_controller_kind", "__meta_kubernetes_pod_controller_name"]
		separator     = "/"
		regex         = "Job/(.+)"
		target_label  = "__tmp_deployment_name"
		replacement   = "${1}"
	}

	// Fallback: use pod controller name directly if no specific pattern matches
	rule {
		source_labels = ["__tmp_deployment_name"]
		regex         = ""
		target_label  = "__tmp_deployment_name"
		replacement   = ""
	}

	rule {
		source_labels = ["__meta_kubernetes_pod_controller_name"]
		target_label  = "__tmp_fallback_name"
	}

	rule {
		source_labels = ["__tmp_deployment_name", "__tmp_fallback_name"]
		separator     = ""
		regex         = "^$(.+)"
		target_label  = "__tmp_deployment_name"
		replacement   = "${1}"
	}

	// Set final labels
	rule {
		source_labels = ["__tmp_deployment_name"]
		target_label  = "service_name"
	}

	rule {
		source_labels = ["__tmp_deployment_name"]
		target_label  = "deployment_name"
	}
}

// ── LOGGING ─────────────────────────────────────────────
loki.write "producttwo" {
	endpoint {
		url     = "http://loki.local/loki/api/v1/push"
		headers = {
			"X-Scope-OrgID" = "myorg-production-producttwo",
		}
	}
}

loki.source.kubernetes "producttwo" {
	targets = discovery.relabel.pod_relabel.output
	forward_to = [loki.write.producttwo.receiver]
}

// ── TRACING ─────────────────────────────────────────────
otelcol.receiver.otlp "producttwo" {
	grpc {
		endpoint = "0.0.0.0:4317"
	}

	http {
		endpoint = "0.0.0.0:4318"
	}

	output {
		traces = [otelcol.processor.attributes.producttwo.input]
	}
}

otelcol.processor.attributes "producttwo" {
	action {
		key    = "business-unit"
		value  = "product-one"
		action = "insert"
	}
	
	// Replace service.name with deployment name from Kubernetes metadata
	action {
		key    = "service.name"
		from_attribute = "k8s.deployment.name"
		action = "upsert"
	}

	output {
		traces = [otelcol.processor.batch.producttwo.input]
	}
}

otelcol.processor.batch "producttwo" {
	output {
		traces = [otelcol.exporter.otlp.producttwo.input]
	}
}

otelcol.exporter.otlp "producttwo" {
	client {
		endpoint = "tempo.local:8444"
		headers  = {
			"X-Scope-OrgID" = "myorg-production-producttwo",
		}

		tls {
			insecure = true
			insecure_skip_verify = true
		}
	}
}